# Архитектура и Поток Данных

## Общая концепция
Приложение работает по циклу **"Запрос → Обработка ИИ → Локальное выполнение → Нарратив"**. Приложение является "толстым клиентом", вся логика изменения состояния (кроме генерации текста) выполняется в браузере.

## Жизненный цикл хода (Game Turn)

Логика сосредоточена в файле `services/geminiService.ts`, функция `processGameTurn`.

### Шаг 1: Сбор данных
*   Берется текущий `GameState` (Мир, Локации, Игроки, Объекты).
*   Берется текстовый ввод пользователя (`userPrompt`).
*   Собирается список активных инструментов (`enabledTools`).

### Шаг 2: Первый запрос к Gemini (Decision Making)
*   Формируется системная инструкция с помощью функции `createSystemInstruction(currentState)`.
*   Отправляется промпт и определения инструментов (`toolDefinitions`).
*   ИИ анализирует ситуацию и решает, какие инструменты вызвать.

### Шаг 3: Локальное выполнение инструментов
*   Если ИИ присылает `functionCall`, приложение **не** отправляет это обратно на сервер сразу.
*   Оно ищет соответствующий TS-файл инструмента в `tools/`.
*   Выполняет функцию `apply(workingState, args)` локально.
*   Это создает `newState` (обновлённое состояние) и текстовый результат выполнения.
*   `workingState` обновляется после каждого успешного вызова инструмента.

### Шаг 4: Второй запрос к Gemini (Narrative Generation)
*   **Важно:** Системная инструкция обновляется с `workingState` (не `currentState`), чтобы ИИ видел актуальное состояние мира после применения инструментов.
*   В историю чата добавляются результаты выполнения инструментов.
*   Отправляется запрос на генерацию финального текста (повествования).

```typescript
// Ключевой момент: AI видит обновлённое состояние
const result2 = await ai.models.generateContent({
    ...
    config: {
        systemInstruction: createSystemInstruction(workingState),  // ← workingState!
        tools: geminiTools 
    }
});
```

### Шаг 5: Обновление UI
*   Пользователю показывается `narrative` (художественный текст).
*   Пользователю показывается `toolLogs` (технические логи вызовов).
*   Пользователю предлагается принять изменения через `DiffView`, которые обновят React State.

## Структура Проекта

```
├── App.tsx                    # Главный компонент приложения
├── index.tsx                  # Точка входа
├── types.ts                   # TypeScript интерфейсы всей системы
├── constants.ts               # Начальное состояние (INITIAL_STATE)
│
├── components/
│   ├── FormEditors.tsx        # UI компоненты редакторов (World, Locations, Players, Objects)
│   ├── DiffView.tsx           # Визуализация изменений состояния
│   └── JsonEditor.tsx         # Редактор сырого JSON
│
├── services/
│   └── geminiService.ts       # Взаимодействие с Gemini API и оркестрация
│
├── tools/                     # Каталог инструментов (см. TOOLS_SYSTEM.md)
│   ├── index.ts               # Регистрация инструментов
│   ├── moveObject.ts          # Перемещение объектов
│   ├── changeObjectState.ts   # Изменение состояния объектов
│   ├── changePlayerState.ts   # Изменение состояния игроков
│   └── changeLocationState.ts # Изменение состояния локаций
│
├── data/                      # Исходные данные для инициализации
│   ├── world.ts
│   ├── locations.ts
│   ├── players.ts
│   └── objects.ts
│
├── utils/
│   ├── gameUtils.ts           # Вспомогательные функции (cloneState)
│   └── dataExporter.ts        # Экспорт данных
│
└── docs/                      # Документация
```

## UI Компоненты

### FormEditors.tsx
Содержит редакторы для всех типов сущностей:
*   `WorldEditor` — редактирование жанра и описания мира
*   `LocationsEditor` — редактирование локаций и их связей
*   `PlayersEditor` — редактирование игроков
*   `ObjectsEditor` — редактирование объектов

**Особенности:**
*   Поля связей (`locationId`, `connectionId`, `targetLocationId`) реализованы как выпадающие списки (`SelectField`) для предотвращения ошибок ввода.
*   Поддержка горячих клавиш (Ctrl+Enter для сохранения).
*   Защита от вмешательства браузерных расширений (random ID, `autocomplete="off"`).

## Обработка Ошибок

### API Errors
Если ключа нет или API недоступен, ошибка выводится в UI с предложением проверить `process.env.API_KEY`.

### Tool Errors
Инструменты реализуют детальную валидацию:
*   Проверка обязательных параметров
*   Проверка существования сущностей по ID
*   Защита от логических ошибок (циклические зависимости, перемещение в себя)

При ошибке возвращается **оригинальное состояние** (не модифицированное) и текстовое описание ошибки. Это описание отправляется обратно ИИ, чтобы он мог обработать неудачу в нарративе.

### Extension Interference
Поля ввода защищены атрибутами (`data-gramm="false"`, `data-lpignore="true"`, `data-1p-ignore="true"`), чтобы расширения браузера (Grammarly, LastPass, 1Password) не ломали React-компоненты.

## Сохранение данных

Приложение поддерживает автосохранение:
1. **API сохранение** — через Vite плагин данные сохраняются в файлы `data/*.ts`
2. **localStorage** — резервная копия, если API недоступен

Автосохранение срабатывает через 2 секунды после последнего изменения (debounce).
