# Архитектура и Поток Данных

## Общая концепция
Приложение работает по циклу **"Запрос → Многоходовая обработка ИИ → Локальное выполнение → Нарратив"**. Приложение является "толстым клиентом", вся логика изменения состояния (кроме генерации текста) выполняется в браузере.

## Жизненный цикл хода (Game Turn)

Логика сосредоточена в файле `services/geminiService.ts`, функция `processGameTurn`.

### Шаг 1: Сбор данных
*   Берется текущий `GameState` (Мир, Локации, Игроки, Объекты).
*   Берется текстовый ввод пользователя (`userPrompt`).
*   Собирается список активных инструментов (`enabledTools`).

### Шаг 2: Первый запрос к Gemini
*   Формируется системная инструкция с помощью функции `createSystemInstruction(currentState)`.
*   Отправляется промпт и определения инструментов (`toolDefinitions`).
*   Включается **thinking mode** (`thinkingConfig`) для получения мыслей модели.
*   ИИ анализирует ситуацию и решает, какие инструменты вызвать.

### Шаг 3: Многоходовый цикл инструментов
**Ключевое отличие от простых реализаций:** AI может вызывать инструменты несколько раз подряд.

```
┌─────────────────────────────────────────┐
│ Первый запрос к AI                      │
└──────────────────┬──────────────────────┘
                   ▼
         ┌─────────────────┐
         │ Есть tool calls?│◄─────────────┐
         └────────┬────────┘              │
            Да    │    Нет                │
                  ▼                       │
┌─────────────────────────────────────────┤
│ Выполняем инструменты локально          │
│ Обновляем workingState                  │
│ Извлекаем мысли (thoughts)              │
│ Отправляем результаты обратно AI        │
└─────────────────────────────────────────┘
                  │ (iteration++)
                  ▼
┌─────────────────────────────────────────┐
│ Извлекаем нарратив из финального ответа │
└─────────────────────────────────────────┘
```

**Защита от бесконечного цикла:** `MAX_TOOL_ITERATIONS = 5`

### Шаг 4: Локальное выполнение инструментов
*   Если ИИ присылает `functionCall`, приложение ищет соответствующий инструмент в `tools/`.
*   Выполняет функцию `apply(workingState, args)` локально.
*   Это создает `newState` (обновлённое состояние) и текстовый результат выполнения.
*   `workingState` обновляется после каждого успешного вызова инструмента.
*   Номер итерации записывается в лог (`iteration`).

### Шаг 5: Извлечение мыслей (Thinking)
*   После каждого ответа AI извлекаются части с `thought: true`.
*   Мысли накапливаются в массив `thinkingParts`.
*   В финальном результате объединяются в поле `thinking`.

```typescript
// Конфигурация thinking mode
const thinkingConfig = {
  includeThoughts: true,  // Включить мысли в ответ
  thinkingBudget: 2048    // Токенов для размышлений
};
```

### Шаг 6: Обновление UI
*   `narrative` — художественный текст
*   `thinking` — мысли модели (раскрывающийся блок)
*   `toolLogs` — логи с группировкой по итерациям (шагам)
*   `DiffView` — предложение принять изменения

## Структура Проекта

```
├── App.tsx                    # Главный компонент приложения
├── index.tsx                  # Точка входа
├── types.ts                   # TypeScript интерфейсы всей системы
├── constants.ts               # Начальное состояние (INITIAL_STATE)
│
├── components/
│   ├── FormEditors.tsx        # UI компоненты редакторов
│   ├── DiffView.tsx           # Визуализация изменений состояния
│   └── JsonEditor.tsx         # Редактор сырого JSON
│
├── services/
│   └── geminiService.ts       # Взаимодействие с Gemini API
│
├── tools/                     # Каталог инструментов
│   ├── index.ts               # Регистрация инструментов
│   ├── moveObject.ts          # Перемещение объектов
│   ├── setAttribute.ts        # Установка атрибутов
│   ├── deleteAttribute.ts     # Удаление атрибутов
│   ├── createObject.ts        # Создание объектов
│   ├── deleteObject.ts        # Удаление объектов
│   └── __tests__/             # Тесты инструментов
│
├── data/                      # Исходные данные
│   ├── world.ts
│   ├── locations.ts
│   ├── players.ts
│   └── objects.ts
│
├── utils/
│   ├── gameUtils.ts           # Вспомогательные функции
│   └── dataExporter.ts        # Экспорт данных
│
└── docs/                      # Документация
```

## Обработка Ошибок

### API Errors
Если ключа нет или API недоступен, ошибка выводится в UI.

### Tool Errors
Инструменты реализуют детальную валидацию:
*   Проверка обязательных параметров
*   Проверка существования сущностей по ID
*   Защита от логических ошибок (циклические зависимости)

При ошибке возвращается **оригинальное состояние** и текстовое описание ошибки.

### Max Iterations
Если AI продолжает вызывать инструменты после 5 итераций, цикл принудительно завершается и генерируется нарратив.

## Типы данных результата

```typescript
interface SimulationResult {
  narrative: string;        // Художественный текст
  toolLogs: ToolCallLog[];  // Логи вызовов инструментов
  newState: GameState;      // Обновлённое состояние
  thinking?: string;        // Мысли модели (опционально)
}

interface ToolCallLog {
  name: string;      // Имя инструмента
  args: any;         // Аргументы
  result: string;    // Результат выполнения
  iteration: number; // Номер итерации (шага)
}
```
